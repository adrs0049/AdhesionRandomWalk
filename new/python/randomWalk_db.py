import db

from db import *
from models import *

from sqlalchemy import exists
import socket

class RandomWalkDB(object):

    def __init__(self):

        self.dbName = 'RandomWalk'

        # setup database
        self.session = setup(url='mysql+mysqldb://adrs0061:it4fOmen@localhost',
            databaseName=self.dbName)

    def getSession(self): return self.session 

    def commit(self): 
        self.session.commit()

    def ParametersToDict(self, p):
        return dict(diffusion_coeff=p.getDiffusion(), 
                    drift_coeff=p.getDrift(),
                    stepSize=p.getDiscreteX(),
                    DomainEndL=p.getDomainShape()[0],
                    DomainEndR=p.getDomainShape()[1],
                    DomainN=p.getDomainSizeL() )

    """ create new Parameter object """
    def createNewParameters(self, P):
        return Parameters(P.getDiffusion(), P.getDrift(),
                          P.getDiscreteX(), P.getDomainShape(),
                          P.getDomainSizeL())

    """ check if a record exists for the C++ parameter object"""
    def isParameter(self, P):
        q = self.session.query(Parameters)
        q = q.filter(exists())
        q = self.queryParamBuilder(q, **self.ParametersToDict(P)) 

        return q.scalar()

    """ This method expects a Parameter class from swig """
    def createParam(self, P):

        if not self.isParameter(P):
            # Diffusion, Drift, stepSize, DomainShape, DomainN
            parameters = self.createNewParameters()

            self.session.add(parameters)
            self.commit()
        else:
            print('Parameters already exists in the database')

    def queryParam(self, **kwargs):
        q = self.session.query(Parameters)
        return self.queryParamBuilder(q, **kwargs)

    def queryParamBuilder(self, query, **kwargs):

        for attr, value in kwargs.iteritems():
            query = query.filter(getattr(Parameters, attr).__eq__(value))
        
        return query

    """ Method to store a path generated by simulator in the database """
    def storePath(self, StateVector, time, rw_id):
        
        rw = self.session.query(RandomWalk).get(rw_id)
        assert rw, "RandomWalk should have been set previously!!"
       
        try:
            xi=0
            for state in StateVector:
                rw.path.append(PathData(coord_x=xi,
                                    coord_y=0,
                                    coord_z=0,
                                    population=state))
                xi+=1
        except:
            self.session.rollback()
            raise
        else:
            self.commit()

    """ Create new Run Record in the DataBase 
        parameters is the wrapped C++ Parameters class """
    def createRandomWalk(self, version, parameters):
        # TODO come up with a better way to deal with the description

        hostname = socket.gethostname()
        machine_id = self.queryMachineRecord(hostname)

        rw = RandomWalk('Space-jump simulation', version,
                parameters.getFinalTime())

        p = self.queryParam(**self.ParametersToDict(parameters)).all()
        m = self.session.query(MachineInfo).get(machine_id)
        # TODO solve this more elegantly
        assert len(p)<2, "Error"

        if not(p):
            p = self.createNewParameters(parameters)
            p.random_walk = [rw]
            self.session.add(p)
        else:
            p=p[0]
        
        m.random_walk.append(rw)
        p.random_walk.append(rw)
        self.commit()
       
        # return the randomWalk id back to the main program
        return rw.id

    """ Create new machine info record """
    def createMachineRecord(self):
        machine = MachineInfo(socket.gethostname())        
        self.session.add(machine)
        self.commit()

    """ Query machine info record """
    def queryMachineRecord(self, hostname):
        stmt = exists().where(MachineInfo.name == hostname)
        q = self.session.query(MachineInfo.name).filter(stmt)

        # if it doesn't exist, create a new record
        if not q.scalar():
            self.createMachineRecord()
            
        # Now that the machine record exists, return its id
        return  self.session.query(MachineInfo.id).filter(MachineInfo.name ==
                hostname).first()
