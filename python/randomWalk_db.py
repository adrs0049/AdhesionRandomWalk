import db

from db import *
from models import *

from sqlalchemy import exists
from sqlalchemy.sql.expression import func
import socket
import datetime
import numpy as np
import pandas as pd

# can we solve this better?
cls_type = sqlalchemy.ext.declarative.api.DeclarativeMeta

class RandomWalkDB(object):

    def __init__(self):

        self.dbName = 'RandomWalk'

        # setup database
        self.engine, self.session = setup(url='mysql+mysqldb://adrs0061:it4fOmen@localhost',
            databaseName=self.dbName)

    def getSession(self): return self.session

    def commit(self):
        self.session.commit()

    def add_and_commit(self, obj):
        try:
            self.session.add(obj)
        except:
            self.session.rollback()
            raise
        else:
            self.commit()

    # TODO reimplement me better!!!
    def ParametersToDict(self, p):
        pass

    """ create new Parameter from dictionary """
    def createNewParameters(self, p):
        ret = Parameters(**p)
        assert ret.is_valid(), 'created Parameters is not valid!'
        return ret

    """ check that a model is valid """
    def is_valid(self, obj):
        # TODO maybe do a very general implementation here ? instead of in
        # each of the model defns?
        return obj.is_valid()

    """ Query for parameters with filters based on dictionary """
    def queryExistsParam(self, P):
        assert isinstance(P, dict), 'Argument P has to be a dictionary'

        q = self.session.query(Parameters)
        q = q.filter(exists())
        q = self.queryParamBuilder(q, **P)

        return q

    """ check if a record exists for data passed as a dictionary """
    def isParameter(self, P):
        return self.queryParam(P).scalar()

    """ Create Parameter entry in DB if it doesn't exist
        param is a dictionary containing some or all values
        of the Parameter object """
    def param_create_if_not_exist(self, param):
        q = self.queryExistsParam(param)

        if not q.scalar():
            parameters = self.createNewParameters(param)
            self.add_and_commit(parameters)
        else:
            print('Parameters already exists in the database')
            # TODO check that this works
            parameters = q.all()[0]

        return parameters

    def queryParam(self, **kwargs):
        q = self.session.query(Parameters)
        return self.queryParamBuilder(q, **kwargs)

    def queryParamBuilder(self, query, **kwargs):

        for attr, value in kwargs.items():
            query = query.filter(getattr(Parameters, attr).__eq__(value))

        return query

    """ get the right field name from Path data """
    def getDataType(self, cls):
        for field in ['population', 'density']:
            if hasattr(cls, field):
                return field

    """ Method to store a path generated by simulator in the database
        cls:         name of ORM object
        stateVector: Simulation data
        SimTime:     time of stateVector
        SimId:       simulation id has to be a valid entry in the database
        stochastic:  was it a stochastic simulation or PDE?
        version:     program version used to create this path
    """
    def storePath(self, stateVector, SimTime, simId,
                  version, stochastic=True, cls=None):

        assert isinstance(stateVector, np.ndarray), "This is only tested with \
                numpy arrays"

        sim = self.getFromId(Simulation, simId)
        assert sim, "SimId:" + SimId + " not found in database!"

        metadata = PathMetaData(stochastic=stochastic,
                                time=SimTime,
                                simulation_date = datetime.datetime.utcnow(),
                                program_version = version)

        sim.paths.append(metadata)

        if not cls:
            if issubclass(stateVector.dtype.type, np.integer):
                cls = StateData
            elif issubclass(stateVector.dtype.type, np.float):
                cls = DensityData
            else:
                assert False, "cls is not set + unknown dtype of stateVector"

        # TODO we would probably survive without storing all the
        # coordinates for all the points!! very expensive
        try:
            for state in stateVector:
                path_point = cls()
                setattr(path_point, self.getDataType(cls), state)

                metadata.path.append(path_point)
        except:
            self.session.rollback()
            raise
        else:
            self.commit()

    """ create simulation """
    def createSimulation(self, description, paramId):

        hostname = socket.gethostname()
        machine_id = self.queryMachineRecord(hostname)

        sim = Simulation(description)

        # Query for both the parameters and machine info to link
        p = self.session.query(Parameters).get(paramId)
        assert p, 'Queried parameter record does not exist. Add it!'

        m = self.session.query(MachineInfo).get(machine_id)
        assert m, 'Queried machine record does not exist. Add it!'

        m.simulations.append(sim)
        p.simulations.append(sim)
        self.commit()

        # return the id to the created sim object
        return sim.id

    """ Query database table by id """
    def getFromId(self, cls, id):
        assert isinstance(id, int), "id has to be an integer"
        assert isinstance(cls, cls_type), "cls has to be sqlalchemy type"
        return self.session.query(cls).get(id)

    """ Query for paramters with id """
    def getParamFromId(self, paramId):
        return self.getFromId(Parameters, paramId)

    """ Query for path with id """
    def getPathFromId(self, pathId):
        return self.getFromId(PathData, pathId)

    """ Query simulation by id """
    def getSimulationFromId(self, simId):
        return self.getFromId(Simulation, simId)

    """ Query for highest id in cls """
    def getMostRecent(self, cls):
        assert isinstance(cls, cls_type), "cls has to be sqlalchemy type"
        return self.session.query(func.max(cls.id)).scalar()

    """ get most recent randomwalk """
    def getMostRecentSimulation(self):
        return self.getMostRecent(Simulation)

    """ Create new machine info record """
    def createMachineRecord(self):
        machine = MachineInfo(socket.gethostname())
        self.add_and_commit(machine)

    """ Query machine info record """
    def queryMachineRecord(self, hostname):
        stmt = exists().where(MachineInfo.name == hostname)
        q = self.session.query(MachineInfo.name).filter(stmt)

        # if it doesn't exist, create a new record
        if not q.scalar():
            self.createMachineRecord()

        # Now that the machine record exists, return its id
        return  self.session.query(MachineInfo.id).filter(MachineInfo.name ==
                hostname).first()

    def returnPath(self, metadataId):
        q = self.session.query(PathData).\
                filter(PathData.metadata_id==metadataId)

        ret = []
        for state in q.all():
            ret.append(float(state.population))

        # check what type the array should be
        if q.first().type == 'state_data':
            return np.array(ret, dtype=np.integer)

        # else it has to be float anyways
        return np.array(ret)

    def returnPathsForSim(self, simId=None):

        if not simId:
            simId = self.getMostRecentSimulation()

        q = self.session.query(PathMetaData.time).\
                filter(PathMetaData.simulation_id==simId)

        time_pts = [float(x[0]) for x in q.all()]

        q = self.session.query(PathMetaData).\
                filter(PathMetaData.simulation_id==simId)

        # list of dataframes
        ddf = dict()

        for time in time_pts:

            # dataframe for return
            rdf = pd.DataFrame()

            q = self.session.query(PathMetaData).\
                filter(PathMetaData.simulation_id==simId).\
                filter(PathMetaData.time==time)

            idx=0
            for metadata in q.all():
                rdf[idx]=self.returnPath(metadata.id)
                idx+=1

            rdf['avg']=rdf.mean(axis=1)
            ddf[time] = rdf

        return ddf

# debugging
if __name__ == '__main__':
    db = RandomWalkDB()

    # TODO read this from an XML file
    param = dict(DomainSize=10, DomainN=10,
                 diffusion_coeff=0.5, drift_coeff=0.0,
                 R=1.0, omega_type=1, omega_p=0.42, g_type=1,
                 u0=0.8, bcs='pp', ic_type=1, ic_p=0.1)


